---
# clean Kubernetes
#  Reset and Clean Kubernetes Node
  
- name: Reset Kubernetes with kubeadm
  shell: kubeadm reset --force
  ignore_errors: true

- name: Remove Kubernetes directories
  file:
    path: "{{ item }}"
    state: absent
  with_items:
    - /etc/kubernetes
    - /var/lib/etcd
    - /var/lib/kubelet
    - /var/lib/cni
    - /var/run/kubernetes

- name: Stop and disable kubelet service
  systemd:
    name: kubelet
    state: stopped
    enabled: no
  ignore_errors: true

- name: Kill kube-apiserver process
  shell: |
        pkill kube-apiserver || true
  ignore_errors: true  # Use if the process might not be running

# update packages
- name: update packages
  command: sudo apt-get update

# copy webapp to remote server
- name: Synchronize a directory to the remote server
  synchronize:
    src: "{{ webapp_local_path }}"
    dest: "{{ webapp_remote_path }}"
    delete: yes  # Optional: delete files in the destination that are not in the source

- name: Install Ansible
  apt:
    name: ansible
    state: present

- name: Install Docker
  apt:
    name: docker.io
    state: present

- name: Install Python 3 and Pip (Debian/Ubuntu)
  ansible.builtin.apt:
    name:
      - python3
      - python3-pip
    state: present
  when: ansible_os_family == "Debian"

- name: Ensure Python 3 and venv are installed
  command: pip3 install kubernetes

- name: install kubernetes.core
  command: ansible-galaxy collection install kubernetes.core


- name: Check if Dockerfile is present
  ansible.builtin.stat:
    path: "{{ dockerfile_path }}/Dockerfile"
  register: dockerfile_stat

- name: Fail if Dockerfile is not present
  ansible.builtin.fail:
    msg: "Dockerfile not found in the specified path"
  when: not dockerfile_stat.stat.exists

- name: Build Docker image
  community.docker.docker_image:
    source: build
    build:
      path: "{{ dockerfile_path }}"
    name: "{{ docker_username }}/{{ image_name }}"
    tag: "{{ image_tag }}"
  when: dockerfile_stat.stat.exists

- name: Log in to Docker Hub
  community.docker.docker_login:
    username: "{{ docker_username }}"
    password: "{{ docker_password }}"
    reauthorize: yes
  register: login_result

- name: Push Docker image to Docker Hub
  community.docker.docker_image:
    name: "{{ docker_username }}/{{ image_name }}"
    tag: "{{ image_tag }}"
    push: yes
    source: local
  when: dockerfile_stat.stat.exists

# - name: Ensure a Docker container is running
#   docker_container:
#     name: webapp419
#     image: "{{ docker_username }}/{{ image_name }}"
#     state: started
#     ports:
#       - "3000:3000"
#     restart_policy: always

- name: k8s repository
  shell: |
          sudo apt-get install -y apt-transport-https ca-certificates curl gpg
          sudo mkdir -p -m 755 /etc/apt/keyrings
          sudo rm -f /etc/apt/keyrings/kubernetes-apt-keyring.gpg
          curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

- name: overwrite existing configuration
  shell: |
          echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

- name: Update the apt package index, install kubelet, kubeadm and kubectl, and pin their version
  shell: |
          sudo apt-get update
          sudo apt-get install -y kubelet kubeadm kubectl
          sudo apt-mark hold kubelet kubeadm kubectl

- name: Enable the kubelet service before running kubeadm
  shell: sudo systemctl enable --now kubelet